Data Structures:
Primitive Data Structures:
These are basic data types provided by programming languages, such as integers, floating-point numbers, characters, and booleans.
Non-Primitive Data Structures:
These are more complex structures built using primitive types, and they can be further divided into linear and non-linear types.
Linear Data Structures: Data elements are arranged sequentially or linearly. Examples include:
Arrays: Fixed-size collections of elements of the same data type, accessed by index.
Linked Lists: Collections of nodes where each node points to the next, allowing for dynamic size.
Stacks: Follow a Last-In, First-Out (LIFO) principle, with operations at one end (top).
Queues: Follow a First-In, First-Out (FIFO) principle, with operations at opposite ends.
Non-Linear Data Structures: Data elements are not arranged sequentially. Examples include:
Trees: Hierarchical structures with nodes connected by edges.
Graphs: Structures representing relationships between data elements through nodes and edges.
Hash Tables: Use a hash function to map keys to values, allowing for efficient data retrieval.
Heaps: Tree-based structures that maintain a specific order among parent and child nodes. 
Algorithms:
Sorting Algorithms:
Arrange data elements in a specific order (e.g., ascending, descending). Examples include:
Comparison-based: Bubble sort, selection sort, insertion sort, merge sort, quicksort, heapsort.
Non-comparison-based: Counting sort, radix sort, bucket sort.
Searching Algorithms:
Locate specific data elements within a data structure. Examples include:
Linear Search: Checks each element sequentially.
Binary Search: Efficiently searches sorted data by repeatedly dividing the search interval.
Graph Algorithms:
Process data within graph structures. Examples include:
Depth-First Search (DFS): Explores as far as possible along each branch before backtracking.
Breadth-First Search (BFS): Explores all the neighboring nodes before moving to the next level.
Other Algorithm Types:
Include algorithms for:
String manipulation: Pattern matching, text compression.
Dynamic programming: Solving complex problems by breaking them down into simpler subproblems.
Greedy algorithms: Making locally optimal choices to find a solution.
Divide and conquer algorithms: Dividing a problem into smaller subproblems, solving them recursively, and combining the solutions. 
